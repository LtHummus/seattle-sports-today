package main

import (
	"bytes"
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"html/template"
	"os"
	"slices"
	"time"

	"github.com/aws/aws-lambda-go/lambda"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"

	"github.com/lthummus/seattle-sports-today/events"
	"github.com/lthummus/seattle-sports-today/notifier"
	"github.com/lthummus/seattle-sports-today/secrets"
	"github.com/lthummus/seattle-sports-today/uploader"
)

//go:embed index.gohtml
var templateString string

var pageTemplate *template.Template

type templateParams struct {
	Events            []*events.Event
	GeneratedDate     string
	FullGeneratedDate template.HTML
}

func init() {
	var err error
	pageTemplate, err = template.New("").Parse(templateString)
	if err != nil {
		log.Fatal().Err(err).Msg("could not parse template")
	}
}

func renderJSON(foundEvents []*events.Event) ([]byte, error) {
	renderableEvents := make([]map[string]string, len(foundEvents))

	for i, curr := range foundEvents {
		e := map[string]string{}
		e["description"] = curr.String()
		if curr.Venue != "" {
			e["venue"] = curr.Venue
		}
		if curr.TeamName != "" {
			e["team_name"] = curr.TeamName
		}
		if curr.Opponent != "" {
			e["opponent"] = curr.Opponent
		}
		if curr.LocalTime != "" {
			e["local_time"] = curr.LocalTime
		}
		renderableEvents[i] = e
	}

	data := map[string]any{
		"date":         events.SeattleCurrentTime.Format("2006-01-02"),
		"events_found": len(foundEvents) != 0,
		"events":       renderableEvents,
	}

	payload, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("renderJSON: could not render: %w", err)
	}

	return payload, nil
}

func renderPage(foundEvents []*events.Event) ([]byte, error) {
	generatedDateString := events.SeattleCurrentTime.Format("Monday Jan _2, 2006")
	log.Info().Int("num_events", len(foundEvents)).Str("formatted_date", generatedDateString).Msg("rendering page")
	buf := bytes.NewBuffer(nil)

	// we have to do things this way because by default the Go HTML templating system will strip out comments. We can force it not
	// to do that by passing this as a template.HTML already so the templating system will plonk it in there no questions asked.

	//#nosec G203 -- This is generated by us with no involvement from the end user
	generatedTimestamp := template.HTML(fmt.Sprintf("<!-- Generated at: %s -->", events.SeattleCurrentTime.Format(time.RFC1123)))

	err := pageTemplate.Execute(buf, &templateParams{Events: foundEvents, GeneratedDate: generatedDateString, FullGeneratedDate: generatedTimestamp})
	if err != nil {
		return nil, fmt.Errorf("renderPage: could not render: %w", err)
	}

	return buf.Bytes(), nil
}

func eventHandler(ctx context.Context) error {
	defer func() {
		if err := recover(); err != nil {
			_ = notifier.Notify(context.Background(), fmt.Sprintf("ERROR: uncaught panic: %v", err), notifier.PriorityHigh, notifier.EmojiSiren)
		}
	}()

	log.Info().Msg("getting today's games")
	foundEvents, err := events.GetTodaysGames(ctx)
	if err != nil {
		_ = notifier.Notify(ctx, fmt.Sprintf("ERROR: could not get today's games: %s", err.Error()), notifier.PriorityHigh, notifier.EmojiSiren)
		return err
	}

	log.Info().Int("games_found", len(foundEvents)).Msg("found games")

	slices.SortFunc(foundEvents, func(a, b *events.Event) int {
		return int(a.RawTime - b.RawTime)
	})

	for _, curr := range foundEvents {
		log.Info().Str("team_name", curr.TeamName).Str("venue", curr.Venue).Str("local_time", curr.LocalTime).Str("opponent", curr.Opponent).Int64("raw_time", curr.RawTime).Msg("found event")
	}

	log.Info().Msg("rendering page")
	page, err := renderPage(foundEvents)
	if err != nil {
		_ = notifier.Notify(ctx, fmt.Sprintf("ERROR: could not render page: %s", err.Error()), notifier.PriorityHigh, notifier.EmojiSiren)
		return err
	}

	jsonData, err := renderJSON(foundEvents)
	if err != nil {
		_ = notifier.Notify(ctx, fmt.Sprintf("ERROR: could not render JSON: %s", err.Error()), notifier.PriorityHigh, notifier.EmojiSiren)
		return err
	}

	log.Info().Msg("render complete")

	if os.Getenv("_HANDLER") != "" || os.Getenv("UPLOAD_ANYWAY") == "true" {
		log.Info().Msg("beginning upload")
		err = uploader.Upload(ctx, page, jsonData)
		if err != nil {
			_ = notifier.Notify(ctx, fmt.Sprintf("ERROR: upload page: %s", err.Error()), notifier.PriorityHigh, notifier.EmojiSiren)
			return err
		}

		log.Info().Msg("upload complete")
	} else {
		log.Warn().Msg("detected running locally, not uploading")
		fmt.Printf("%s\n----------\n%s\n", string(jsonData), string(page))
	}

	log.Info().Msg("all in a day's work...")

	err = notifier.Notify(ctx, fmt.Sprintf("Everything worked! Found %d game(s)", len(foundEvents)), notifier.PriorityDefault, notifier.EmojiParty)
	if err != nil {
		log.Warn().Err(err).Msg("error sending notification")
	}

	return nil
}

func main() {
	log.Info().Msg("hello world")

	err := secrets.Init(context.Background())
	if err != nil {
		log.Fatal().Err(err).Msg("could not initialize secrets manager client")
	}
	
	if os.Getenv("_HANDLER") != "" {
		lambda.Start(eventHandler)
	} else {
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
		err := eventHandler(context.Background())
		if err != nil {
			log.Error().Err(err).Msg("error running handler")
		}
	}
}
